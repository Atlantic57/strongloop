
module.exports.MultiRegClient = MultiRegClient
module.exports.getConfig = getConfig;
module.exports.createClient = createClient;

var RegClient = require('npm-registry-client'),
    parseUrl = require('url').parse;

try {
  npmlog = require("npmlog")
} catch (er) {
  npmlog = { error: noop, warn: noop, info: noop,
             verbose: noop, silly: noop, http: noop,
             pause: noop, resume: noop }
}

function noop () {}


function RegConf(base, specific) {
  function get(key) {
    var val;
    
    if (key === 'registry') {
      if (typeof specific.get === 'function')
        return specific.get('url');
      else
        return specific.url;
    }
    
    if (typeof specific.get === 'function')
      val = specific.get(key);
    else
      val = specific[key];
      
    if (val !== undefined)
      return val;
      
    if (typeof base.get === 'function')
      return base.get(key);
    else
      return base[key];    
  }
  
  function set(key, value) {
    if (typeof specific.set === 'function')
      specific.set(key, value);
    else
      specific[key] = value;
    }
  
  function del(key) {
    if (typeof specific.del === 'function')
      specific.del(key);
    else
      delete specific[key];
      
    if (typeof base.del === 'function')
      base.del(key);
    else
      delete base[key];
  }
  
  this.get = get;
  this.set = set;
  this.del = del;
}


function wrapConfigObject(conf) {
  // accept either a plain-jane object, or a npmconf object
  // with a "get" method.
  if (typeof conf.get !== 'function') {
    var data = conf
    conf = { get: function (k) { return data[k] }
           , set: function (k, v) { data[k] = v }
           , del: function (k) { delete data[k] } }
  }
  
  return conf;
}

function MultiRegClient(conf) {
  conf = wrapConfigObject(conf);
  
  var registry = conf.get('registry');
  if (typeof registry !== 'object')
    throw new Error("Configuration doesn't specify multiple registries");
 
  var registries = [];
 
  for (var name in registry) {
    if (!registry.hasOwnProperty(name))
      continue;
      
    var regConf = new RegConf(conf, registry[name]),
        client = new RegClient(regConf);
    
    registries.push({
      name: name,
      conf: regConf,
      client: client
    });
  }
  
  this.conf = conf;
  this.registries = registries;
  
  this.get = getImplementation('get', 'install', true, registries);
  this.publish = getImplementation('publish', 'publish', false, registries);
  this.adduser = getImplementation('adduser', 'publish', false, registries);
  this.request = getImplementation('request', 'publish', false, registries);
  this.star = getImplementation('star', 'install', true, registries);
  this.tag = getImplementation('tag', 'publish', false, registries);
  this.unpublish = getImplementation('unpublish', 'publish', false, registries);
  this.upload = getImplementation('upload', 'publish', false, registries);
}


function getImplementation(method, purpose, tryMultiple, registries) {
  // Compute the order in which registries are tried.
  
  function getPriority(registry) {
    var priority;
    
    if (purpose)
      priority = registry.conf.get(purpose + '-priority');
        
    if (priority === undefined)
      priority = registry.conf.get('priority');
      
    if (priority === undefined)
      priority = 1;
      
    return +priority;
  }
  
  registries = registries.filter(function(registry) {
    return getPriority(registry) >= 0;
  });

  registries.sort(function(reg1, reg2) {
    return getPriority(reg2) - getPriority(reg1);
  });
  
  // If trying multiple registries isn't applicable to the method, just
  // return the implementation method for the specific registry.
  if (!tryMultiple) {
    var client = registries[0].client;
    return client[method].bind(client);
  } else {
    return wrapper;
  }
  
  function wrapper() {
    // Replace callback by wrapper callback that tries multiple repos.
    var args = Array.prototype.slice.call(arguments),
        originalCallback = args[args.length - 1];
    args[args.length - 1] = wrapperCallback;
    
    // Start at the registry with the highest priority.
    var registryIndex = 0;
    callClient();
  
    function callClient() {
      var client = registries[registryIndex].client;
      client[method].apply(client, args);
    }
  
    function wrapperCallback(err) {
      if (err && err.code === 'E404' &&
          registryIndex < registries.length) {
        registryIndex++;
        return callClient();
      }
      
      originalCallback.apply(this, arguments);
    }
  }
}


function getConfig(conf, url) {
  conf = wrapConfigObject(conf);
  
  // If there's just one registry defined, use the global config object.
  if (!(conf.get('registry') instanceof Object))
    return conf;
    
  // If multiple registries are defined, find the registry associated with this
  // particular url.
  var registries = conf.get('registry');
  
  if (typeof url !== 'object')
    url = parseUrl(url);
  
  for (var key in registries) {
    if (!registries.hasOwnProperty(key))
      continue;
      
    var regConf = new RegConf(conf, registries[key]),
        regUrl = parseUrl(regConf.get('registry'));
    
    if (url.host == regUrl.host &&
        url.path.indexOf(regUrl.path) === 0)
      return regConf;
  }
  
  return null;
}


function createClient(conf) {
  var conf = wrapConfigObject(conf);
  
  if (!(conf.get('registry')) instanceof Object)
    return new RegClient(conf);
  else
    return new MultiRegClient(conf);
}